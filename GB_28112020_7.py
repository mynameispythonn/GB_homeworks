# #1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который
# должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц вы найдете в методичке.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix
# (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы
# складываем с первым элементом первой строки второй матрицы и т.д.


class Matrix:
    def __init__(self, ms):
        self.ms = ms

    def __str__(self):
        return "\n".join(map(str, self.ms))

    def __add__(self, other):
        new_m = []
        for i in range(len(self.ms)):
            new_m.append([])
            for j in range(len(self.ms[0])):
                new_m[i].append(self.ms[i][j] + other.ms[i][j])
        return Matrix(new_m)

m_1 = Matrix([[3, 12, 678],
              [34, 567, 0],
              [54, 0, 45]])
m_2 = Matrix([[234, 64, -45],
              [3, 6, -44],
              [54, -4, -42]])
print(m_1 + m_2)


# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого
# проекта — одежда, которая может иметь определенное название. К типам одежды в этом проекте относятся пальто и костюм.
# У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа:
# V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма
# (2 * H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать
# абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.


from abc import abstractmethod, ABC

class Clothes(ABC):
    def __init__(self, param):
        self.param = param

    def __add__(self, other):
        return f"Общий расход ткани составил: {self.param + other.param}"

    @abstractmethod
    def get_sqpt(self):
        pass

class Coat(Clothes):

    def get_sqpt(self):
        print(f"Расход ткани для пальто составил: {self.param / 6.5 + 0.5} метра")

class Suit(Clothes):

    def get_sqpt(self):
        print(f"Расход костюма для пальто составил: {2 * self.param + 0.3} метра")

coat = Coat(2)
suit = Suit(56)
coat.get_sqpt()
suit.get_sqpt()
print(coat + suit)

# or

class Clothes:
    def __init__(self, V, H):
        self.V = V
        self.H = H

    def S_coat(self):
        return self.V / 6.5 + 0.5

    def S_suit(self):
        return self.H * 2 + 0.3

    @property
    def S_cs(self):
        return str(f'Общий расход ткани составил {(self.V / 6.5 + 0.5) + (self.H * 2 + 0.3)}')

#
class Coat(Clothes):
    def __init__(self, V, H):
        super().__init__(V, H)
        self.square_c = self.V / 6.5 + 0.5

    def __str__(self):
        return f'Расход ткани для пальто составил: {self.square_c}'


class Suit(Clothes):
    def __init__(self, V, H):
        super().__init__(V, H)
        self.square_s = round(self.H * 2 + 0.3)

    def __str__(self):
        return f'Расход ткани для костюма составил: {self.square_s}'

coat = Coat(2, 4)
suit = Suit(1, 2)
print(coat.S_coat())
print(suit.S_suit())

print(coat)
print(suit)




# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе
# инициализировать параметр, соответствующий количеству клеток (целое число). В классе должны быть реализованы методы
# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление
# (__truediv__()).Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и
# обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться округление
# значения до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток
# больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек
# этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный
# метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет
# строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет
# строку: *****\n*****\n*****.


class Cell():

    def __init__(self, num_cells):
        self.num_cells = num_cells

    def __str__(self):
        return self.num_cells

    def __add__(self, other):
        return f'{self.num_cells + other.num_cells}\n'

    def __sub__(self, other):
        return f'{int(self.num_cells - other.num_cells)}\n' if int(self.num_cells - other.num_cells) > 0 else \
            "Error. Please, try other cell"

    def __mul__(self, other):
        return f'{self.num_cells * other.num_cells}\n'

    def __truediv__(self, other):
        return f'{round(self.num_cells // other.num_cells)}\n'

    def make_order(self, r_cells):
        row = ""
        for g in range(int(self.num_cells / r_cells)):
            row += f'{"*" * r_cells}\n'
        return row


c_1 = Cell(12)
c_2 = Cell(6)
c_3  = Cell(56)
print(c_1 + c_2)
print(c_1 - c_2)
print(c_1 / c_2)
print(c_1.make_order(2))
print(c_2.make_order(4))
print(c_3.make_order(7))
