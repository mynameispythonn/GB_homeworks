# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе
# инициализировать параметр, соответствующий количеству клеток (целое число). В классе должны быть реализованы методы
# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление
# (__truediv__()).Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и
# обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться округление
# значения до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток
# больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек
# этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный
# метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет
# строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет
# строку: *****\n*****\n*****.


class Cell():

    def __init__(self, num_cells):
        self.num_cells = num_cells

    def __str__(self):
        return self.num_cells

    def __add__(self, other):
        return f'{self.num_cells + other.num_cells}\n'

    def __sub__(self, other):
        return f'{int(self.num_cells - other.num_cells)}\n' if int(self.num_cells - other.num_cells) > 0 else \
            "Error. Please, try other cell"

    def __mul__(self, other):
        return f'{self.num_cells * other.num_cells}\n'

    def __truediv__(self, other):
        return f'{round(self.num_cells // other.num_cells)}\n'

    def make_order(self, r_cells):
        row = ""
        for g in range(int(self.num_cells / r_cells)):
            row += f'{"*" * r_cells}\n'
        return row


c_1 = Cell(12)
c_2 = Cell(6)
c_3  = Cell(56)
print(c_1 + c_2)
print(c_1 - c_2)
print(c_1 / c_2)
print(c_1.make_order(2))
print(c_2.make_order(4))
print(c_3.make_order(7))


# 1. Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки формата
# «день-месяц-год». В рамках класса реализовать два метода. Первый, с декоратором @classmethod, должен извлекать
# число, месяц, год и преобразовывать их тип к типу «Число». Второй, с декоратором @staticmethod, должен проводить
# валидацию числа, месяца и года (например, месяц — от 1 до 12). Проверить работу полученной структуры
# на реальных данных.


class Data:

    def __init__(self, date):
        self.date = date

    def __str__(self):
        return f"Date is {Data.n_date(self.date)}"

    @classmethod
    def n_date(cls, date):
        new_date = []
        for i in date.split("-"):
            if i != "-": new_date.append(i)
        return f"{int(new_date[0])}.{int(new_date[1])}.{int(new_date[2])}"

    @staticmethod
    def origin(yy, mm, dd):
        return "this date is real" if 1 <= dd <= 31 and 1 <= mm <= 12 and 2020 >= yy >= 0 else \
            "Error. Please, try other cell"

    ## через этот метод выдает ошибку почему-то


lesson_day = Data("02-12-2001")
print(lesson_day)
print(Data.origin(15, 96, 2800))
print(Data.origin(16, 8, 1996))
print(Data.origin(31, 12, 986))



